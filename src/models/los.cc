#include <stdio.h>
#include <math.h>
#include "../main.hh"
#include "los.hh"
#include "cost.hh"
#include "ecc33.hh"
#include "ericsson.hh"
#include "fspl.hh"
#include "hata.hh"
#include "itwom3.0.hh"
#include "sui.hh"
#include "pel.hh"
#include "egli.hh"
#include "soil.hh"
#include "../geo.hh"
#include <mutex>
#include <spdlog/spdlog.h>
#include <vector>
#include <limits.h>

namespace {
	bool ***processed;
	bool has_init_processed = false;

    // Storage for processing threads
    std::vector<std::thread> threads;

    // Storage for processing thread futures
    std::vector<std::future<void *>> futures;

    // Mutex for processed vector
    std::mutex maskMutex;

    // Thread progress vector
    std::vector<progress_t> thread_progress;

    // This is a 3D vector of the pixels & layers in our plot that have or have not been processed
    std::vector<std::vector<std::vector<bool>>> processedPoints;

	void init_processed()
	{
		int i;
		int x;
		int y;

		/*processed = new bool **[MAXPAGES];
		for (i = 0; i < MAXPAGES; i++) {
			processed[i] = new bool *[ippd];
			for (x = 0; x < ippd; x++)
				processed[i][x] = new bool [ippd];
		}*/

        // Initialize our vector to the correct size (this is ugly but apparently the best way to do this)
        processedPoints = std::vector<std::vector<std::vector<bool>>>(MAXPAGES, std::vector<std::vector<bool>>(ippd, std::vector<bool>(ippd)));

        // Populate our processedPoints vector with the points to process
		for (i = 0; i < MAXPAGES; i++) {
			for (x = 0; x < ippd; x++) {
				for (y = 0; y < ippd; y++) {
                    processedPoints[i][x][y] = false;
					//processed[i][x][y] = false;
                } 
			}
		}

        spdlog::debug("Initialized processedPoints vector of side {}x{}x{}", MAXPAGES, ippd, ippd);

		has_init_processed = true;
	}

	bool can_process(double lat, double lon)
	{
		/* Lines, text, markings, and coverage areas are stored in a
		mask that is combined with topology data when topographic
		maps are generated by ss.  This function sets bits in
		the mask based on the latitude and longitude of the area
		pointed to. */

		int x, y, indx;
		char found;
		bool rtn = false;

		for (indx = 0, found = 0; indx < MAXPAGES && found == 0;) {
			x = (int)rint(ppd * (lat - dem[indx].min_north));
			y = mpi - (int)rint(yppd * (LonDiff(dem[indx].max_west, lon)));

			if (x >= 0 && x <= mpi && y >= 0 && y <= mpi)
				found = 1;
			else
				indx++;
		}

		if (found) {
			/* As long as we only set this without resetting it we can
			check outside a mutex first without worrying about race 
			conditions. But we must lock the mutex before updating the 
			value. */
			if(!processedPoints[indx][x][y]) {
				maskMutex.lock();
				if(!processedPoints[indx][x][y]) {
					rtn = true;
					processedPoints[indx][x][y] = true;
				}
				maskMutex.unlock();
			}

		}
		return rtn;
	}

    /**
     * Calulate a propagation for a specific range
     * 
     * @param *parameters parameters object for the propagation range
    */
	void* rangePropagation(progress_t &progress, void *parameters)
	{
        // Create propagationRange opbject based on our parameters
		PropagationRange *v = (PropagationRange*)parameters;
		if(v->use_threads) {
			alloc_elev();
			alloc_path();
		}

        // Check if we're plotting a single line
        if (v->min_north == v->max_north && v->min_west == v->max_west) {
            spdlog::warn("Propagation plot range is a single point!");
        }

        // If our min & max lon coords are the same, it's a vertical line
        bool vertical = (v->min_west == v->max_west) ? true : false;

        // Calculate total number of points we are going to process
        unsigned int totalPoints = vertical ? (int)((v->max_north - v->min_north) / dpp) : (int)((v->max_west - v->min_west) / dpp);
        progress.total.store(totalPoints);

        // Init the count
        progress.count.store(0);

        spdlog::debug("Starting rangePropagation for {} range {:.6f}N {:.6f}W to {:.6f}N {:.6f}W, {} points at {:.8f} dpp [Segment {}]",
            vertical ? "vertical" : "horizontal",
            v->min_north, v->min_west, v->max_north, v->max_west, progress.total.load(), dpp, progress.id);

        // Init our varaibles for tracking position over the loop
        double lat = v->min_north;
        double lon = v->min_west;
        int y = 0;
        // Iterate
		do {
			if (lon >= 360.0)
				lon -= 360.0;

			site edge;
			edge.lat = lat;
			edge.lon = lon;
			edge.alt = v->altitude;

            //spdlog::debug("Plotting propagation path to {:.6f}N {:.6f}W", edge.lat, edge.lon);

			if(v->los)
				PlotLOSPath(v->source, edge, v->mask_value);
			else
				PlotPropPath(v->source, edge, v->mask_value, v->fd, v->prop_model,
					v->knifeedge, v->pmenv);
            // Increment our counters
			++y;
            progress.count++;
            // Incremenet our lat/lon as needed
			if(vertical) {
                lat = (double)v->min_north + (dpp * (double)y);
            } else {
			    lon = (double)v->min_west + (dpp * (double)y);
            }

        } while ( vertical ? (lat < (double)v->max_north) : (LonDiff(lon, (double)v->max_west) <= 0.0) );

        if(v->use_threads) {
            free_elev();
            free_path();
		}
		return NULL;
	}

    void* radiusPropagation(progress_t &progress, void *parameters)
    {
        // Create a prop radius from our parameters
        PropagationRadius *r = (PropagationRadius*)parameters;

        // Thread buffer allocation
        if(r->use_threads) {
			alloc_elev();
			alloc_path();
		}

        // Check if our start & stop angles are the same
        if (r->start_angle_rad == r->stop_angle_rad)
        {
            spdlog::warn("Start & stop angles are the same, this radius segment will be a single line");
        }

        spdlog::debug("Starting radiusPropagation for range {:.2f} to {:.2f}, {} points, {:.8f} dpp",
            r->start_angle_rad / DEG2RAD, r->stop_angle_rad / DEG2RAD, r->points, dpp);

        // Get the amount in radians to increment per iteration
        double rps = (r->stop_angle_rad - r->start_angle_rad) / r->points;

        // Iterate
        double rad = r->start_angle_rad;
        for (int i = 0; i < r->points; i++)
        {
            // Get coordinates of point on circle
            coord point = getPointAtDistance({r->source.lat, r->source.lon}, r->radius, rad / DEG2RAD);
            // Create site for prop path
            site edge;
            edge.lat = point.lat;
            edge.lon = point.lon;
            edge.alt = r->altitude;
            // Plot
            if (r->los)
                PlotLOSPath(r->source, edge, r->mask_value);
            else
                PlotPropPath(r->source, edge, r->mask_value, r->fd, r->prop_model, r->knifeedge, r->pmenv);

            // Increment
            rad += rps;
        }

        // Double check we covered the whole range
        if (rad < (r->stop_angle_rad - 0.01f))
        {
            spdlog::warn("Only got to {:.2f} degrees when we expected to get to {:.2f} degrees", rad / DEG2RAD, r->stop_angle_rad / DEG2RAD);
        }

        // Free the buffers we made earlier
        if(r->use_threads) {
            free_elev();
            free_path();
		}

        return NULL;
    }

	/// @brief Wait for all threads in our threads array to finish
	void finishThreads()
	{
        for (auto& th : threads)
            th.join();
	}

    /// @brief Wait for the progress accumulators to finish, then finish out any running threads
    void finishProgress()
    {
        unsigned int total_points = 0;
        unsigned int points_processed = 0;
        
        // Calculate the expected total progress count
        for (const auto& p : thread_progress)
        {
            if (p.total <= 0) { std::this_thread::sleep_for( std::chrono::milliseconds(2) ); }
            total_points += p.total;
        }

        spdlog::debug("{} total points to process", total_points);
        
        // Await progress completion
        while (points_processed < total_points)
        {
            std::this_thread::sleep_for( std::chrono::milliseconds(500) );

            // Reset count for this check
            points_processed = 0;

            for (const auto& p : thread_progress)
            {
                points_processed += p.count;
            }

            // Update print
            spdlog::info("[{: 3d}%] Processing {}/{} points", int(points_processed * 100 / total_points), points_processed, total_points);
        }
    }
}

/*
 * Acute Angle from Rx point to an obstacle of height (opp) and
 * distance (adj)
 */
static double incidenceAngle(double opp, double adj)
{
	return atan2(opp, adj) * 180 / PI;
}

/*
 * Knife edge diffraction:
 * This is based upon a recognised formula like Huygens, but trades
 * thoroughness for increased speed which adds a proportional diffraction
 * effect to obstacles.
 */
static double ked(double freq, double rxh, double dkm)
{
	double obh, obd, rxobaoi = 0, d;

	obh = 0;		// Obstacle height
	obd = 0;		// Obstacle distance

	dkm = dkm * 1000;	// KM to metres

	// walk along path
	for (int n = 2; n < (dkm / elev[1]); n++) {

		d = (n - 2) * elev[1];	// no of points * delta = km

		//Find dip(s)
		if (elev[n] < obh) {

			// Angle from Rx point to obstacle
			rxobaoi =
			    incidenceAngle((obh - (elev[n] + rxh)), d - obd);
		} else {
			// Line of sight or higher
			rxobaoi = 0;
		}

		//note the highest point
		if (elev[n] > obh) {
			obh = elev[n];
			obd = d;
		}

	}

	if (rxobaoi >= 0) {
		return (rxobaoi / (300 / freq))+3;	// Diffraction angle divided by wavelength (m)
	} else {
		return 1;
	}
}

void PlotLOSPath(struct site source, struct site destination, char mask_value)
{
    /* This function analyzes the path between the source and
       destination locations. It determines which points along

       the path have line-of-sight visibility to the source.
       Points with line-of-sight visibility to the source are
           stored by setting bit 1 in the mask[][] array, which are
           displayed in green when PPM maps are later generated by ss. */

    bool bStop;
    int x, iCounter;
    double cos_angle, cos_test_angle, cos_horizon_angle, cos_limit_angle, rx_alt2;
    double distance, rx_alt, tx_alt, limit_alt, distance2, tx_alt2, test_alt, test_alt2, limit_alt2;

    ReadPath(source, destination);

    distance = 0.0;
    tx_alt = 0.0;
    distance2 = 0.0;
    tx_alt2 = 0.0;
    rx_alt2 = 0.0;
    test_alt = 0.0;
    test_alt2 = 0.0;
    limit_alt2 = 0.0;
    cos_horizon_angle = 1.0;
    bStop = false;
    iCounter = 0;

    /* altitude limit of 32808 feets or 10000 meters */
    limit_alt = earthradius + 32808.0;
    limit_alt2 = limit_alt * limit_alt;

    tx_alt = earthradius + source.alt + path.elevation[0];
    tx_alt2 = tx_alt * tx_alt;

    for (x = 0; (bStop == false) && (x < (path.length - 1)) && (path.distance[x] <= max_range); x++) {

        if (x > 0) {
            distance = FEET_PER_MILE * path.distance[x];
            distance2 = distance * distance;

            rx_alt = earthradius + destination.alt + path.elevation[x];
            rx_alt2 = rx_alt * rx_alt;

            /* Calculate the cosine of the elevation between
               transmitter and receiver. */

            cos_angle = (distance2 + tx_alt2 - rx_alt2) / (2.0 * distance * tx_alt);

            if (cos_angle > 1.0) {
                cos_angle = 1.0;
            }

            if (cos_angle < -1.0) {
                cos_angle = -1.0;
            }

            test_alt = earthradius + (path.elevation[x] == 0.0 ? path.elevation[x] : path.elevation[x] + clutter);
            test_alt2 = test_alt * test_alt;

            /* Calculate the cosine of the elevation between
               transmitter and this test point. */

            cos_test_angle = (distance2 + tx_alt2 - test_alt2) / (2.0 * distance * tx_alt);
        }
        else {
            cos_angle = -1.0;
            cos_test_angle = 1.0;
        }

        /* Compare these two angles to determine if
           an obstruction exists.
           Mark this point only if it hasn't been already marked */

        if ((cos_horizon_angle >= cos_angle) && ((GetMask(path.lat[x], path.lon[x]) & mask_value) == 0) && (can_process(path.lat[x], path.lon[x]))) {
            OrMask(path.lat[x], path.lon[x], mask_value);
        }

        if (cos_test_angle < cos_horizon_angle) {
            cos_horizon_angle = cos_test_angle;
        }

        if ((x > 0) && (cos_horizon_angle < 0.0)) {
            if (iCounter > 10) {
                /* Check for Mount Everest in line-of-sight visibility */

                /* Calculate the cosine of the elevation between
                   transmitter and altitude limit. */

                cos_limit_angle = (distance2 + tx_alt2 - limit_alt2) / (2.0 * distance * tx_alt);

                if (cos_limit_angle > 1.0) {
                    cos_limit_angle = 1.0;
                }

                if (cos_limit_angle < -1.0) {
                   cos_limit_angle = -1.0;
                }

                if (cos_limit_angle > cos_horizon_angle) {
                    bStop = true;
                }

                iCounter = 0;
            }
            else {
                iCounter++;
            }
        }
    }
}

/**
 * Calculate propagation for the points on a line between two coordinates
 * 
 * @param source - the source site object
 * @param destination - the destination site object
*/
void PlotPropPath(
    struct site source, 
    struct site destination,
	unsigned char mask_value, 
    FILE * fd, 
    PropModel prop_model,
	int knifeedge, 
    int pmenv
)
{

	int x, y, ifs, ofs, errnum;
	char block = 0, strmode[100];
	double loss, azimuth, pattern = 0.0,
	    xmtr_alt, dest_alt, xmtr_alt2, dest_alt2,
	    cos_rcvr_angle, cos_test_angle = 0.0, test_alt,
	    elevation = 0.0, distance = 0.0, four_thirds_earth,
	    field_strength = 0.0, rxp, dBm, diffloss;
	struct site temp;
	float dkm;

	ReadPath(source, destination);

	four_thirds_earth = FOUR_THIRDS * EARTHRADIUS;

	for (x = 1; x < path.length - 1; x++)
		elev[x + 2] =
		    (path.elevation[x] ==
		     0.0 ? path.elevation[x] * METERS_PER_FOOT : (clutter +
								  path.
								  elevation[x])
		     * METERS_PER_FOOT);


	/* Copy ending points without clutter */

	elev[2] = path.elevation[0] * METERS_PER_FOOT;

	elev[path.length + 1] =
	    path.elevation[path.length - 1] * METERS_PER_FOOT;

	/* Since the only energy the Longley-Rice model considers
	   reaching the destination is based on what is scattered
	   or deflected from the first obstruction along the path,
	   we first need to find the location and elevation angle
	   of that first obstruction (if it exists).  This is done
	   using a 4/3rds Earth radius to match the model used by
	   Longley-Rice.  This information is required for properly
	   integrating the antenna's elevation pattern into the
	   calculation for overall path loss. */
	//if(debug)
	//	fprintf(stderr,"four_thirds_earth %.1f source.alt %.1f path.elevation[0] %.1f\n",four_thirds_earth,source.alt,path.elevation[0]);
	for (y = 2; (y < (path.length - 1) && path.distance[y] <= max_range);
	     y++) {
		/* Process this point only if it
		   has not already been processed. */

		if ( (GetMask(path.lat[y], path.lon[y]) & 248) !=
			(mask_value << 3) && can_process(path.lat[y], path.lon[y])) {

			char fd_buffer[64];
			int buffer_offset = 0;

			distance = FEET_PER_MILE * path.distance[y];
			xmtr_alt =
			    four_thirds_earth + source.alt + path.elevation[0];
			dest_alt =
			    four_thirds_earth + destination.alt +
			    path.elevation[y];
			dest_alt2 = dest_alt * dest_alt;
			xmtr_alt2 = xmtr_alt * xmtr_alt;

			/* Calculate the cosine of the elevation of
			   the receiver as seen by the transmitter. */

			cos_rcvr_angle =
			    ((xmtr_alt2) + (distance * distance) -
			     (dest_alt2)) / (2.0 * xmtr_alt * distance);

			if (cos_rcvr_angle > 1.0)
				cos_rcvr_angle = 1.0;

			if (cos_rcvr_angle < -1.0)
				cos_rcvr_angle = -1.0;

			if (got_elevation_pattern || fd != NULL) {
				/* Determine the elevation angle to the first obstruction
				   along the path IF elevation pattern data is available
				   or an output (.ano) file has been designated. */

				for (x = 2, block = 0; (x < y && block == 0);
				     x++) {
					distance = FEET_PER_MILE * path.distance[x];

					test_alt =
					    four_thirds_earth +
					    (path.elevation[x] ==
					     0.0 ? path.elevation[x] : path.
					     elevation[x] + clutter);

					/* Calculate the cosine of the elevation
					   angle of the terrain (test point)
					   as seen by the transmitter. */

					cos_test_angle =
					    ((xmtr_alt2) +
					     (distance * distance) -
					     (test_alt * test_alt)) / (2.0 *
								       xmtr_alt
								       *
								       distance);

					if (cos_test_angle > 1.0)
						cos_test_angle = 1.0;

					if (cos_test_angle < -1.0)
						cos_test_angle = -1.0;

					/* Compare these two angles to determine if
					   an obstruction exists.  Since we're comparing
					   the cosines of these angles rather than
					   the angles themselves, the sense of the
					   following "if" statement is reversed from
					   what it would be if the angles themselves
					   were compared. */

					if (cos_rcvr_angle >= cos_test_angle)
						block = 1;
				}

				if (block)
					elevation =
					    ((acos(cos_test_angle)) / DEG2RAD) -
					    90.0;
				else
					elevation =
					    ((acos(cos_rcvr_angle)) / DEG2RAD) -
					    90.0;
			}

			/* Determine attenuation for each point along the
			   path using a prop model starting at y=2 (number_of_points = 1), the
			   shortest distance terrain can play a role in
			   path loss. */

			elev[0] = y - 1;	/* (number of points - 1) */

			/* Distance between elevation samples */

			elev[1] =
			    METERS_PER_MILE * (path.distance[y] -
					       path.distance[y - 1]);

			if (path.elevation[y] < 1) {
				path.elevation[y] = 1;
			}

			dkm = (elev[1] * elev[0]) / 1000;	// km

			switch (prop_model) {
			
                case ITM_LR:
                    // Longley Rice ITM
                    point_to_point_ITM(source.alt * METERS_PER_FOOT,
                            destination.alt *
                            METERS_PER_FOOT,
                            LR.eps_dielect,
                            LR.sgm_conductivity,
                            LR.eno_ns_surfref,
                            LR.frq_mhz, LR.radio_climate,
                            LR.pol, LR.conf, LR.rel,
                            loss, strmode, errnum);
                    break;
                
                case HATA:
                    //HATA 1, 2 & 3
                    loss =
                        HATApathLoss(LR.frq_mhz, source.alt * METERS_PER_FOOT,
                            (path.elevation[y] * METERS_PER_FOOT) +	 (destination.alt * METERS_PER_FOOT), dkm, pmenv);
                    break;
                
                case ECC33:
                    // ECC33
                    loss =
                        ECC33pathLoss(LR.frq_mhz, source.alt * METERS_PER_FOOT,
                            (path.elevation[y] *
                            METERS_PER_FOOT) +
                            (destination.alt *
                            METERS_PER_FOOT), dkm,
                            pmenv);
                    break;
                
                case SUI:
                    // SUI
                    loss =
                        SUIpathLoss(LR.frq_mhz, source.alt * METERS_PER_FOOT,
                            (path.elevation[y] *
                            METERS_PER_FOOT) +
                            (destination.alt *
                            METERS_PER_FOOT), dkm, pmenv);
                    break;
                
                case COST231_HATA:
                    // COST231-Hata
                    loss =
                        COST231pathLoss(LR.frq_mhz, source.alt * METERS_PER_FOOT,
                            (path.elevation[y] *
                            METERS_PER_FOOT) +
                                (destination.alt *
                                METERS_PER_FOOT), dkm,
                                pmenv);
                    break;
                
                case ITU_R:
                    // ITU-R P.525 Free space path loss
                    loss = FSPLpathLoss(LR.frq_mhz, dkm, false);
                    break;
                
                case ITWOM_3:
                    // ITWOM 3.0
                    point_to_point(source.alt * METERS_PER_FOOT,
                            destination.alt *
                            METERS_PER_FOOT, LR.eps_dielect,
                            LR.sgm_conductivity,

                            LR.eno_ns_surfref, LR.frq_mhz,
                            LR.radio_climate, LR.pol,
                            LR.conf, LR.rel, loss, strmode,
                            errnum);
                    break;
                
                case ERICSSON:
                    // Ericsson
                    loss =
                        EricssonpathLoss(LR.frq_mhz, source.alt * METERS_PER_FOOT,
                            (path.elevation[y] *
                            METERS_PER_FOOT) +
                                (destination.alt *
                                METERS_PER_FOOT), dkm,
                                pmenv);
                    break;
                
                case PLANE_EARTH:
                    // Plane earth
                    loss =	PlaneEarthLoss(dkm, source.alt * METERS_PER_FOOT, (path.elevation[y] * METERS_PER_FOOT) + (destination.alt * METERS_PER_FOOT));
                    break;
                
                case ELGI_V_U:
                    // Egli VHF/UHF
                    loss = EgliPathLoss(LR.frq_mhz, source.alt * METERS_PER_FOOT, (path.elevation[y] * METERS_PER_FOOT) + (destination.alt * METERS_PER_FOOT),dkm);
                    break;
                
                case SOIL:
                    // Soil
                    loss = SoilPathLoss(LR.frq_mhz, dkm, LR.eps_dielect);
                    break;

                default:
                    spdlog::warn("Defaulting to ITM propagation model");
                    point_to_point_ITM(source.alt * METERS_PER_FOOT,
                            destination.alt *
                            METERS_PER_FOOT,
                            LR.eps_dielect,
                            LR.sgm_conductivity,
                            LR.eno_ns_surfref,
                            LR.frq_mhz, LR.radio_climate,
                            LR.pol, LR.conf, LR.rel,
                            loss, strmode, errnum);
			}

			if (knifeedge == 1 && prop_model > 1) {
				diffloss =
				    ked(LR.frq_mhz,
					destination.alt * METERS_PER_FOOT, dkm);
				loss += (diffloss);	// ;)
			}
			//Key stage. Link dB for p2p is returned as 'loss'.

			temp.lat = path.lat[y];
			temp.lon = path.lon[y];

			azimuth = (Azimuth(source, temp));

			if (fd != NULL)
				buffer_offset += sprintf(fd_buffer+buffer_offset,
					"%.7f, %.7f, %.3f, %.3f, ",
					path.lat[y], path.lon[y], azimuth,
					elevation);

			/* If ERP==0, write path loss to alphanumeric
			   output file.  Otherwise, write field strength
			   or received power level (below), as appropriate. */

			if (fd != NULL && LR.erp == 0.0)
				buffer_offset += sprintf(fd_buffer+buffer_offset,
					"%.2f", loss);

			/* Integrate the antenna's radiation
			   pattern into the overall path loss. */

			x = (int)rint(10.0 * (10.0 - elevation));

			if (x >= 0 && x <= 1000) {
				azimuth = rint(azimuth);

				pattern =
				    (double)LR.antenna_pattern[(int)azimuth][x];

				if (pattern != 0.0) {
					pattern = 20.0 * log10(pattern);
					loss -= pattern;
				}
			}

			if (LR.erp != 0.0) {
				if (dbm) {
					/* dBm is based on EIRP (ERP + 2.14) */

					rxp =
					    LR.erp /
					    (pow(10.0, (loss - 2.14) / 10.0));

					dBm = 10.0 * (log10(rxp * 1000.0));

					if (fd != NULL)
						buffer_offset += sprintf(fd_buffer+buffer_offset,
							"%.3f", dBm);

					/* Scale roughly between 0 and 255 */

					ifs = 200 + (int)rint(dBm);

					if (ifs < 0)
						ifs = 0;

					if (ifs > 255)
						ifs = 255;

					ofs =
					    GetSignal(path.lat[y], path.lon[y]);

					if (ofs > ifs)
						ifs = ofs;

					PutSignal(path.lat[y], path.lon[y],
						  (unsigned char)ifs);

				}

				else {
					field_strength =
					    (139.4 +
					     (20.0 * log10(LR.frq_mhz)) -
					     loss) +
					    (10.0 * log10(LR.erp / 1000.0));

					ifs = 100 + (int)rint(field_strength);

					if (ifs < 0)
						ifs = 0;

					if (ifs > 255)
						ifs = 255;

					ofs =
					    GetSignal(path.lat[y], path.lon[y]);

					if (ofs > ifs)
						ifs = ofs;

					PutSignal(path.lat[y], path.lon[y],
						  (unsigned char)ifs);

					if (fd != NULL)
						buffer_offset += sprintf(fd_buffer+buffer_offset,
							"%.3f",
							field_strength);
				}
			}

			else {
				if (loss > 255)
					ifs = 255;
				else
					ifs = (int)rint(loss);
				
				ofs = GetSignal(path.lat[y], path.lon[y]);

				if (ofs < ifs && ofs != 0)
					ifs = ofs;

				PutSignal(path.lat[y], path.lon[y],
					  (unsigned char)ifs);
			}

			if (fd != NULL) {
				if (block)
					buffer_offset += sprintf(fd_buffer+buffer_offset,
						" *");
				fprintf(fd, "%s\n", fd_buffer);
			}

			/* Mark this point as having been analyzed */

			PutMask(path.lat[y], path.lon[y],
				(GetMask(path.lat[y], path.lon[y]) & 7) +
				(mask_value << 3));
		}
	}

	if(path.lat[y]>cropLat)
		cropLat=path.lat[y];

	
	if(y>cropLon)
		cropLon=y;

	//if(cropLon>180)
	//	cropLon-=360;
}

void PlotLOSMap(struct site source, double altitude, char *plo_filename,
		bool use_threads, uint8_t segments)
{
	/* This function performs a 360 degree sweep around the
	   transmitter site (source location), and plots the
	   line-of-sight coverage of the transmitter on the ss
	   generated topographic map based on a receiver located
	   at the specified altitude (in feet AGL).  Results
	   are stored in memory, and written out in the form
	   of a topographic map when the WritePPM() function
	   is later invoked. */

	static __thread unsigned char mask_value = 1;
	FILE *fd = NULL;

	if (plo_filename[0] != 0)
		fd = fopen(plo_filename, "wb");

	if (fd != NULL) {
		fprintf(fd,
			"%.3f, %.3f\t; max_west, min_west\n%.3f, %.3f\t; max_north, min_north\n",
			max_west, min_west, max_north, min_north);
	}

	// Four sections start here
	// Process north edge east/west, east edge north/south,
	// south edge east/west, west edge north/south
	double range_min_west[] = {min_west, min_west, min_west, max_west};
	double range_min_north[] = {max_north, min_north, min_north, min_north};
	double range_max_west[] = {max_west, min_west, max_west, max_west};
	double range_max_north[] = {max_north, max_north, min_north, max_north};
	PropagationRange *r = new PropagationRange[segments];

    // Size our progress vector appropriately
    thread_progress = std::vector<progress_t>(segments);

	for(int i = 0; i < segments; ++i) {
        r[i].los = true;

		r[i].eastwest = (range_min_west[i] == range_max_west[i] ? false : true);
		r[i].min_west = range_min_west[i];
		r[i].max_west = range_max_west[i];
		r[i].min_north = range_min_north[i];
		r[i].max_north = range_max_north[i];

		r[i].use_threads = use_threads;
		r[i].altitude = altitude;
		r[i].source = source;
		r[i].mask_value = mask_value;
		r[i].fd = fd;

        // Set the segment id
        thread_progress[i].id = i;

		if(use_threads)
			//threads.push_back(std::thread(rangePropagation, i, &r[i]));
            futures.push_back( std::async( std::launch::async, rangePropagation, std::ref(thread_progress[i]), &r[i] ) );
		else
			rangePropagation(thread_progress[i], &r[i]);
	}

	if(use_threads)
		finishThreads();

	delete[] r;

	switch (mask_value) {
	case 1:
		mask_value = 8;
		break;

	case 8:
		mask_value = 16;
		break;

	case 16:
		mask_value = 32;
	}
}

/// @brief Plot propagation from a source using a bounding box and the specified plot parameters
/// @param source source site
/// @param bounds bounding box
/// @param altitude antenna altitude
/// @param plo_filename plot filename
/// @param prop_model propagation model to use
/// @param knifeedge whether to use knife edge propagation
/// @param haf 
/// @param pmenv 
/// @param use_threads whether to use threads or not
/// @param segments number of segments to divide the plot by
void PlotPropagation(struct site source, bbox bounds, 
                    double altitude, char *plo_filename,
		            PropModel prop_model, int knifeedge, int haf, int pmenv, bool
		            use_threads, uint8_t segments)
{
	static __thread unsigned char mask_value = 1;
	FILE *fd = NULL;

    char plotType[32];
	
	if (LR.erp == 0.0 && debug)
		sprintf(plotType, "path loss");
	else {
		if (debug) {
			if (dbm)
				sprintf(plotType, "signal power level");
			else
				sprintf(plotType, "field strength");
		}
	}
	spdlog::debug("Plotting {} contours of \"{}\" out to a radius of {:.2f} {} with Rx antenna(s) at {:.2f} {} AGL",
            plotType,
			source.name,
			metric ? max_range * KM_PER_MILE : max_range,
			metric ? "kilometers" : "miles",
			metric ? altitude * METERS_PER_FOOT : altitude,
			metric ? "meters" : "feet");

	if (clutter > 0.0)
        spdlog::debug("Using {:.2f} {} of ground clutter", metric ? clutter * METERS_PER_FOOT : clutter, metric ? "meters" : "feet");

    spdlog::debug("TX site location: {:.6f}N {:.6f}W at {:.2f} ft AGL", source.lat, source.lon, source.alt);

	if (plo_filename[0] != 0)
		fd = fopen(plo_filename, "wb");

	if (fd != NULL) {
		fprintf(fd,
			"%.3f, %.3f\t; max_west, min_west\n%.3f, %.3f\t; max_north, min_north\n",
			bounds.upper_left.lon, bounds.lower_right.lon, bounds.upper_left.lat, bounds.lower_right.lat);
	}

    double plot_width = bounds.upper_left.lon - bounds.lower_right.lon;
    double plot_height = bounds.upper_left.lat - bounds.lower_right.lat;

    /**
     * EXAMPLE - 6 segments
     * 
     * We divide our area into as follows:
     * __|__1__|__2__|__
     *   |           |
     * 6 |           | 3
     * __|___________|__
     *   |  5  |  4  |
     * 
    */

    // NUM_SECTIONS must always be a multiple of 2 and greater than 4, because we have to divide a 4-sided rectangle equally
    uint8_t lon_edge_segments = (segments / 4);   // Our longitudal edges (top & bottom) will get the greater of the two segment counts
    uint8_t lat_edge_segments = (segments / 2) - lon_edge_segments; // Our latitudal edges are whatever is left over

    // Calculate the widths of each segment
    double edge_width = plot_width / lon_edge_segments;
    double edge_height = plot_height / lat_edge_segments;

	spdlog::debug("With {} sections, our {:.6f} x {:.6f} area will be divided into {} x {} edge segments of size {:.6f} x {:.6f} deg", 
        segments, plot_width, plot_height, lon_edge_segments, lat_edge_segments, edge_width, edge_height
    );
	
    // Array to hold our edge ranges
    std::vector<PropagationRange> ranges;

    // Create our longitudal (top and bottom edge) ranges
    for (int i = 0; i < lon_edge_segments; i++) {
        // Create two ranges for the top & bottom edges which will share longitude values
        PropagationRange top_range;
        PropagationRange bot_range;
        // We're not doing an LOS plot
        top_range.los = false;
        bot_range.los = false;
        // Calculate the longitudes for both ranges
        double lon_min = bounds.lower_right.lon + (edge_width * i);
        double lon_max = bounds.lower_right.lon + (edge_width * (1+i));
        // Set top (on our max_north latitude)
        top_range.min_west = lon_min;
        top_range.max_west = lon_max;
        top_range.min_north = bounds.upper_left.lat;
        top_range.max_north = bounds.upper_left.lat;
        // Set bottom (on our min_north latitude)
        bot_range.min_west = lon_min;
        bot_range.max_west = lon_max;
        bot_range.min_north = bounds.lower_right.lat;
        bot_range.max_north = bounds.lower_right.lat;
        // Append to our vector
        ranges.push_back(top_range);
        ranges.push_back(bot_range);
        // Log
        spdlog::debug("Added top & bottom segments from {:.6f}W to {:.6f}W", lon_min, lon_max);
    }

    // Create our latitudal (left and right) ranges
    for (int i = 0; i < lat_edge_segments; i++) {
        // Create two ranges for the left & right edges since they share latitude values
        PropagationRange left_range;
        PropagationRange right_range;
        // We're not doing an LOS plot
        left_range.los = false;
        right_range.los = false;
        // Calculate the latitude start & stop for both ranges
        double lat_min = bounds.lower_right.lat + (edge_height * i);
        double lat_max = bounds.lower_right.lat + (edge_height * (i+1));
        // Set left (on our max_west longitude)
        left_range.min_west = bounds.upper_left.lon;
        left_range.max_west = bounds.upper_left.lon;
        left_range.min_north = lat_min;
        left_range.max_north = lat_max;
        // Set right (on our min_west longitude)
        right_range.min_west = bounds.lower_right.lon;
        right_range.max_west = bounds.lower_right.lon;
        right_range.min_north = lat_min;
        right_range.max_north = lat_max;
        // Append to our vector
        ranges.push_back(left_range);
        ranges.push_back(right_range);
        // Log
        spdlog::debug("Added left & right segments from {:.6f}N to {:.6f}N", lat_min, lat_max);
    }

    // Make sure we didn't do anythng wrong
    if (ranges.size() != segments) {
        spdlog::error("Our vector of ranges ({}) does not match expected segment count {}", ranges.size(), segments);
        exit(1);
    }

    // Size our progress vector appropriately
    thread_progress = std::vector<progress_t>(segments);
    
    // Init our vector for storing processing progress
    if (!has_init_processed) {
        init_processed();
    }

    // Iterate over the final list of ranges
    for (size_t i = 0; i < ranges.size(); i++) {
        // Set common variables
        ranges[i].use_threads = use_threads;
        ranges[i].altitude = altitude;
        ranges[i].source = source;
        ranges[i].mask_value = mask_value;
        ranges[i].fd = fd;
        ranges[i].prop_model = prop_model;
        ranges[i].knifeedge = knifeedge;
        ranges[i].pmenv = pmenv;
        // Set the segment id
        thread_progress[i].id = i;
        // Start a thread if we're using threads
        if (use_threads) {
            spdlog::debug("Starting calc thread for edge segment {:.6f}N {:.6f}W to {:.6f}N {:.6f}W", ranges[i].min_north, ranges[i].min_west, ranges[i].max_north, ranges[i].max_west);
            //threads.push_back(std::thread(rangePropagation, i, &ranges[i]));
            futures.push_back( std::async( std::launch::async, rangePropagation, std::ref(thread_progress[i]), &ranges[i] ) );
        }
        else {
            spdlog::debug("Starting single-thread calc for edge segment {:.6f}N {:.6f}W to {:.6f}N {:.6f}W", ranges[i].min_north, ranges[i].min_west, ranges[i].max_north, ranges[i].max_west);
            rangePropagation(thread_progress[i], &ranges[i]);
        }
    }

	// Wait for threads to finish
	if(use_threads)
    {
        spdlog::debug("Waiting for threads to finish...");
        //finishThreads();
        finishProgress();
    }

	for(size_t i = 0; i < ranges.size(); i++){
		ranges.erase(ranges.begin() + i);
	}

    if (fd != NULL)
		fclose(fd);

	if (mask_value < 30)
		mask_value++;
}

void PlotPropagationRadius(struct site source, double range, 
                            double altitude, char *plot_filename, 
                            PropModel prop_model, int knifeedge, int haf, int pmenv, 
                            bool use_threads, uint8_t segments)
{

    // Convert our imperial units to metric if needed
    if (metric)
    {
        range *= KM_PER_MILE;
        altitude *= METERS_PER_FOOT;
    }

    // Ensure segments is a logical value
    if ((segments % 2 != 0) && (segments % 3 != 0))
    {
        spdlog::error("Segment number must be an multiple of either 2 or 3!");
        exit(1);
    }

    static __thread unsigned char mask_value = 1;
	FILE *fd = NULL;

    // Get plot type string
    char plotType[32];
	if (LR.erp == 0.0 && debug)
		sprintf(plotType, "path loss");
	else {
		if (debug) {
			if (dbm)
				sprintf(plotType, "signal power level");
			else
				sprintf(plotType, "field strength");
		}
	}
    // Print debug
	spdlog::debug("Plotting {} contours of \"{}\" out to a radius of {:.2f} km with Rx antenna(s) at {:.2f} m AGL",
            plotType,
			source.name,
			range,
			altitude
    );

    // Optional clutter debug print
	if (clutter > 0.0)
        spdlog::debug("Using {:.2f} {} of ground clutter", metric ? clutter * METERS_PER_FOOT : clutter, metric ? "meters" : "feet");

    // TX site location print
    spdlog::debug("TX site location: {:.6f}N {:.6f}W at {:.2f} ft AGL", source.lat, source.lon, source.alt);

    // Get bounding box of plot
    bbox bounds = getCircularBoundingBox( {source.lat, source.lon}, range);

    // Open file and ensure it opened
	if (plot_filename[0] != 0)
		fd = fopen(plot_filename, "wb");
	if (fd != NULL) {
		fprintf(fd,
			"%.3f, %.3f\t; max_west, min_west\n%.3f, %.3f\t; max_north, min_north\n",
			bounds.upper_left.lon, bounds.lower_right.lon, bounds.upper_left.lat, bounds.lower_right.lat);
	}

    // Calculate plot width & height in degrees
    double plot_width = bounds.upper_left.lon - bounds.lower_right.lon;
    double plot_height = bounds.upper_left.lat - bounds.lower_right.lat;

    // Calculate the radius of our circle, in pixels
    double radius_px = (plot_width / 2.0) * ppd;

    // Calculate the total number of pixels/points in our plot circle using the midpoint circle algorithm
    // Borrowed from https://math.stackexchange.com/a/167310
    // We use the upper bound to ensure we don't miss any points
    int circle_pixels = (int)ceil(radius_px * 6.283);

    // Calculte the size of each angular degree section, in rads
    double section_size_rad = 360.0 / segments * DEG2RAD;

    // Calculate the number of points/pixels in each segment
    int section_pixels = (int)(circle_pixels / segments);

    // Create our ranges
    std::vector<PropagationRadius> radii;

    // Iterate through our segments
    for (int i = 0; i < segments; i++)
    {
        // Create a new radius
        PropagationRadius propRadius;
        // Populate static data
        propRadius.source = source;
        propRadius.radius = range;
        propRadius.points = section_pixels;
        propRadius.use_threads = use_threads;
        propRadius.altitude = altitude;
        propRadius.mask_value = mask_value;
        propRadius.fd = fd;
        propRadius.prop_model = prop_model;
        propRadius.knifeedge = knifeedge;
        propRadius.pmenv = pmenv;
        // We're not doing LOS
        propRadius.los = false;
        // Calculate start and stop angles
        propRadius.start_angle_rad = i * section_size_rad;
        propRadius.stop_angle_rad = (i + 1) * section_size_rad;

        // Add to list
        radii.push_back(propRadius);
    }

	spdlog::debug("With {} segments and {} total points, our circular area will be divided into {:.2f}-degree (or {} point) segments", 
                    segments, circle_pixels, section_size_rad / DEG2RAD, section_pixels);

    // Make sure we didn't do anythng wrong
    if (radii.size() != segments) {
        spdlog::error("Our vector of radii ({}) does not match expected segment count {}", radii.size(), segments);
        exit(1);
    }

    // Size our progress vector appropriately
    thread_progress = std::vector<progress_t>(segments);

    // Init our vector for storing processing progress
    if (!has_init_processed) {
        init_processed();
    }

    // Iterate over the final list of ranges
    for (size_t i = 0; i < radii.size(); i++) {
        // Set the segment id
        thread_progress[i].id = i;
        // Start a thread if we're using threads
        if (use_threads) {
            spdlog::debug("Starting calc thread for radius segment {:.2f} to {:.2f}", radii[i].start_angle_rad / DEG2RAD, radii[i].stop_angle_rad / DEG2RAD);
            futures.push_back( std::async( std::launch::async, radiusPropagation, std::ref(thread_progress[i]), &radii[i] ) );
        }
        else {
            spdlog::debug("Starting single-thread calc for radius segment {:.2f} to {:.2f}", radii[i].start_angle_rad / DEG2RAD, radii[i].stop_angle_rad / DEG2RAD);
            radiusPropagation(thread_progress[i], &radii[i]);
        }
    }

    // Wait for threads to finish
	if(use_threads)
    {
        spdlog::debug("Waiting for threads to finish...");
        finishThreads();
    }

    // Clean up our radii
	for(size_t i = 0; i < radii.size(); i++){
		radii.erase(radii.begin() + i);
	}

    // Close the file
    if (fd != NULL)
    {
        fclose(fd);
    }

	if (mask_value < 30)
    {
        mask_value++;
    }
}

void PlotPath(struct site source, struct site destination, char mask_value)
{
	/* This function analyzes the path between the source and
	   destination locations.  It determines which points along
	   the path have line-of-sight visibility to the source.
	   Points along with path having line-of-sight visibility
	   to the source at an AGL altitude equal to that of the
	   destination location are stored by setting bit 1 in the
	   mask[][] array, which are displayed in green when PPM
	   maps are later generated by SPLAT!. */

	char block;
	int x, y;
	register double cos_xmtr_angle, cos_test_angle, test_alt;
	double distance, rx_alt, tx_alt;

	ReadPath(source, destination);

	for (y = 0; y < path.length; y++) {
		/* Test this point only if it hasn't been already
		   tested and found to be free of obstructions. */

		if ((GetMask(path.lat[y], path.lon[y]) & mask_value) == 0) {
			distance = FEET_PER_MILE * path.distance[y];
			tx_alt = earthradius + source.alt + path.elevation[0];
			rx_alt =
			    earthradius + destination.alt + path.elevation[y];

			/* Calculate the cosine of the elevation of the
			   transmitter as seen at the temp rx point. */

			cos_xmtr_angle =
			    ((rx_alt * rx_alt) + (distance * distance) -
			     (tx_alt * tx_alt)) / (2.0 * rx_alt * distance);

			for (x = y, block = 0; x >= 0 && block == 0; x--) {
				distance =
				    FEET_PER_MILE * (path.distance[y] -
					      path.distance[x]);
				test_alt =
				    earthradius + (path.elevation[x] ==
						   0.0 ? path.
						   elevation[x] : path.
						   elevation[x] + clutter);

				cos_test_angle =
				    ((rx_alt * rx_alt) + (distance * distance) -
				     (test_alt * test_alt)) / (2.0 * rx_alt *
							       distance);

				/* Compare these two angles to determine if
				   an obstruction exists.  Since we're comparing
				   the cosines of these angles rather than
				   the angles themselves, the following "if"
				   statement is reversed from what it would
				   be if the actual angles were compared. */

				if (cos_xmtr_angle >= cos_test_angle)
					block = 1;
			}

			if (block == 0)
				OrMask(path.lat[y], path.lon[y], mask_value);
		}
	}
}
